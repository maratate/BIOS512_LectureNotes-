Lecture 5 - Tidy Data 

Anytime we see data we are actually seeing less thnan there actually is becasue of discrete data sets 

Wide data sets 
- Wide data often has missing data 
_______________________________________________________________________________________________________

Joins - Allow us to take data from multiple tables and combine for one big table 

Joins Definitions  
- table: a data structure with some columns (usually named) and some rows.
- observation: one item of interest (often one row, but not always)
- key: a column or columns (almost always unique) which identifies an observation (example integer ID)
- join: the process of combining tables (almost always using keys), matching keys in 2 tables and combining them
- query: a program which uses some tables, joins, filters, subsets columns, creates new columns, and returns a new table
- relational data(base): a collection of tables organized along the above lines
- pivot: when we change our notion of observation we "pivot" our data so that we have one row per observation.
         - pivot to a different representation of our data 

All we have to do to understand joins is just think carefully about all the ways we might want to put data together.

_______________________________________________________________________________________________________
Pivots

Again, if we first understand that we want _one observation per row_ then pivots
make sense.  

Consider our original table:

:table:source_data/frat_boys_basic.csv::

The observation here is one person per row. But what if someone approached you
and asked "How much information do we have about each student in this data set?"

In that case a single observation is "a student and a recording of some data."

From that point of view, multiple observations occur on each row of our basic data
set and we want to *pivot* to a different conception of an observation.

```sidebar
Nota bene: You often see people name variables `df` or `data.` Even I do it. This
is ok for quick demonstrations but there is something to consider - short
variable names don't convey much information and they sometimes overlap with 
functions defined in the global scope (both df and data have this issue) which can
cause confusing errors. It is usually good to give concise but informative names.
```

```R 
library(tidyverse)

students <- read_csv("source_data/frat_boys_basic.csv")

# note we pivot _longer_ because we need more rows for our observations
student_data <- pivot_longer(students, fraternity:dietary_preference)

mddf(student_data)
```
- Pivot_longer is a function in tidyverse - takes input data set and sepcfiy columns that we want to pivot 
- There will be an error when you pivot longer and the coloumn created for the pairing has different data types (string, number)

We got an error - this is an example of a type failure. To understand this we need
to consider the following things:

1. tibbles/data frames are lists of columns which are R vectors
2. R vectors are homogeneous in type
3. When we pivot longer we are trying to put all the different values in 
   different columns into a single column (thus requiring more rows)
4. but our original columns have different types.

There are ways to deal with this. One is to pivot multiple times based on 
the types of columns we have and then join the data back together, resulting in
a frame where each row is a value observation but with multiple columns, one
per type.

We could also  use a list column and wrap our elements so we can have a heterogeneous
column.

The easiest thing is to just convert everything to characters and reconvert later - a perilous
thing to do but OK for now.

```R 
library(tidyverse)

students <- read_csv("source_data/frat_boys_basic.csv")


# note we pivot _longer_ because we need more rows for our observations
student_data <- pivot_longer(students, fraternity:dietary_preference,
  names_to = "property",
  values_to = "observation",
  values_transform = function(x) ifelse(is.na(x), NA, as.character(x)))

mddf(student_data)

```
OK, so now we can answer the given question: how much data do we have on
each student?

```R 

library(tidyverse)

students <- read_csv("source_data/frat_boys_basic.csv")

mdpre(problems(students))


# note we pivot _longer_ because we need more rows for our observations
student_data <- pivot_longer(students, fraternity:dietary_preference,
  names_to = "property",
  values_to = "observation",
  values_transform = function(x) ifelse(is.na(x), NA, as.character(x))) %>%
  filter(complete.cases(.)) 
#this will remove any observations with missinf data

ensure_directory("derived_data")
write_csv(student_data, "derived_data/student_long.csv");

mddf(student_data %>% 
                 group_by(name) %>%  
                 tally() %>% 
                 arrange(desc(n)))
#group by student and count 
```
. = current wokring dataframe 

_______________________________________________________________________________________________________
Pivot_wider

Just as often we want to go the other way. If we were asked to plot the students in 2D using some kind of dimensionality reduction
we'd need to convert the long data from above into a data set where each row is one student. We do that
with a `pivot_wider` because we will end up with fewer rows and more columns (a wider data frame).

```R 
library(tidyverse)

long_data <- read_csv("derived_data/student_long.csv")

mddf(long_data %>% 
      pivot_wider(id_cols=name, names_from=property, values_from=observation))
```
Have to idenity the columns that coresspond to the idenification you are intrested in 

_______________________________________________________________________________________________________

Joins 

Because data is often intentionally separated into different data sets in databases,
we often have to put it back together, but in fact, sometimes we are putting together
data from entirely different sources or data sets, and in that case we need to
do joins regardless.

Joins work like this:

Compare some subset of values from each data frame - these are the "keys" since
they determine which rows go together. Then we collect together the columns
from each data set when the keys match. 

Simple! But we need to decide a few things about what to do about missing data and this leads to different joins.

1. "left" table is literally the table we start with and is on our left
2. "right" table is the table we are working with and is our our right sytactically

First perhaps the most obvious sort of thing. We want to combine students
with their majors and we want to know which students may not yet have chosen
a major. This is called a "left" join because we keep everything in the left
table and fill in NA's if we don't have data in the right table. 
_______________________________________________________________________________________________________

Left Joins 

```R 
library(tidyverse)

students <- read_csv("source_data/student.csv")
majors <- read_csv("source_data/major.csv")
fraternities <- read_csv("source_data/fraternity.csv")
addresses <- read_csv("source_data/address.csv")
props <- read_csv("source_data/student_properties.csv")

# LEFT JOIN: keep all students, attach majors when present
mdpre(paste(
  "students:", nrow(students),
  "majors:", nrow(majors)
))
students_majors_left <- students %>%
  left_join(majors %>% rename(major_name = name, major_address_id = address_id),
            by = c("major_id" = "id")) %>%
  select(id, name, major_id, major_name, enrollment_date, gpa)

mdpre(paste("left join rows:", nrow(students_majors_left)))
mddf(students_majors_left)
```
By is matching by major_id and ID 
- if there is no match will perserve the rows in left dataset and the observaton will just have missing data 
- only see rows coressponsing to the left table 
_______________________________________________________________________________________________________

Inner Join (contrived) - both tables matter, result is only rows where we get a match 
- Always going to end up with as many or fewer rows than when you started 
- should count number of joins before and after and log it (comment it)

Sometimes the most direct way to see what an inner join does is with a tiny example.

```R 
library(tidyverse) 

# CONTRIVED INNER JOIN: only rows with matching keys survive
left_df <- tibble(id = c(1, 2, 3), val_left = c("A", "B", "C"))
right_df <- tibble(id = c(2, 3, 4), val_right = c("X", "Y", "Z"))

mdpre("left")
mddf(left_df)

mdpre("right")
mddf(right_df)

mdpre(paste(
  "left rows:", nrow(left_df),
  "right rows:", nrow(right_df)
))

inner_df <- left_df %>% inner_join(right_df, by = "id")

mdpre(paste("inner rows:", nrow(inner_df)))
mddf("inner join")
mddf(inner_df)
```
![](joins.png)
Right and full
--------------

```R 
library(tidyverse)

students <- read_csv("source_data/student.csv")
majors <- read_csv("source_data/major.csv")
fraternities <- read_csv("source_data/fraternity.csv")
addresses <- read_csv("source_data/address.csv")
props <- read_csv("source_data/student_properties.csv")

# RIGHT JOIN: keep all properties, even if there is no matching student
mdpre(paste(
  "students:", nrow(students),
  "properties:", nrow(props)
))
props_right <- students %>%
  right_join(props, by = c("id" = "student_id"))

# Row count after right join
mdpre(paste("right join rows:", nrow(props_right)))

# Observe the intentionally dangling properties with student_id = 99
mddf(props_right %>% filter(is.na(name)))

# FULL JOIN: keep all students and all properties
props_full <- students %>%
  full_join(props, by = c("id" = "student_id"))

mdpre(paste("full join rows:", nrow(props_full)))
mddf(props_full)
```

Semi and anti
-------------

```R 
# SEMI JOIN: which students have at least one property row?
mdpre(paste("students:", nrow(students)))
has_props <- students %>% semi_join(props, by = c("id" = "student_id"))

# ANTI JOIN: which students have no properties? (may be empty)
no_props <- students %>% anti_join(props, by = c("id" = "student_id"))

mdpre(paste(
  "with props:", nrow(has_props),
  "without props:", nrow(no_props)
))
mddf(has_props)
mddf(no_props)
```

Joining lookups
---------------

```R 
# Join fraternities to their address; note missing address for one fraternity
mdpre(paste(
  "fraternities:", nrow(fraternities),
  "addresses:", nrow(addresses)
))
frats_with_addresses <- fraternities %>%
  left_join(addresses %>% rename(
    frat_street = line1, frat_city = city, frat_state = state
  ), by = c("address_id" = "id"))

mdpre(paste("frat left join rows:", nrow(frats_with_addresses)))
mddf(frats_with_addresses)

# Join students to their own address; note a missing student address_id
mdpre(paste(
  "students:", nrow(students),
  "addresses:", nrow(addresses)
))
students_with_address <- students %>%
  left_join(addresses %>% rename(
    student_street = line1, student_city = city, student_state = state
  ), by = c("address_id" = "id"))

mdpre(paste("student left join rows:", nrow(students_with_address)))
mddf(students_with_address)
```

Chaining joins
--------------

```R 
# Build a richer table by chaining left joins to keep all students
mdpre(paste("students:", nrow(students)))
student_profile <- students %>%
  left_join(majors %>% rename(major_name = name, major_address_id = address_id),
            by = c("major_id" = "id")) %>%
  left_join(fraternities %>% rename(frat_name = name, frat_address_id = address_id),
            by = c("fraternity_id" = "id")) %>%
  left_join(addresses %>% rename(
    student_street = line1, student_city = city, student_state = state
  ), by = c("address_id" = "id")) %>%
  left_join(addresses %>% rename(
    major_street = line1, major_city = city, major_state = state
  ), by = c("major_address_id" = "id")) %>%
  left_join(addresses %>% rename(
    frat_street = line1, frat_city = city, frat_state = state
  ), by = c("frat_address_id" = "id")) %>%
  select(
    id, name, major_name, frat_name,
    student_street, student_city,
    major_street, major_city,
    frat_street, frat_city
  )

mdpre(paste("profile rows:", nrow(student_profile)))
mddf(student_profile)
```




